



\begin{figure*}[tb]
\centering
\includegraphics[width=0.78\textwidth]{illustrations/refactoringTree.eps}
\vspace{-6pt}
\caption{Equivalence classes with various representations. DBB = Double-Bounded, SNG = Single Bounded, LWB = Lower Bounded, CCC = Custom Character Class and LIT = Literal. We use concrete regexes in the representations for illustration. However, the A's in the LWB group (or B's in DBB group, S's in SNG group, and so forth) abstractly represent any pattern that could be operated on by a repetition modifier (e.g., literal characters, character classes, or groups). The same is true for the literals used in all the representations. }
\vspace{-6pt}
\label{fig:refactoringTree}
\end{figure*}


\section{Research Questions}
\label{sec:study}
%After defining the equivalence classes and potential  regex refactorings as described in Section~\ref{sec:refactoring}, we wanted to know which representations in the equivalence classes  are considered desirable and which might be smelly. Desirability for regexes can be defined many ways, including maintainable,  understandable, and performance. 
%%As prior work has shown that regexes are difficult to read~\cite{}, 
%We focus on refactoring for understandability.

To explore regex comprehension and identify smells, we answer the following research questions: \\
%We define regex understandability two ways. First,  we  present people with regexes exemplifying some of the more common characteristics and ask them comprehension questions along two directions: determine which of a list of strings are matched by the regex, and compose a string that is matched by the regex. Second, assuming that common programming practices are more understandable than uncommon practices, we explore the frequencies of each representation from Figure~\ref{fig:refactoringTree} using thousands of regexes scraped from Python projects. 

\noindent {\textbf{RQ1:}} {\em Which regex representations are most understandable?}
To answer RQ1, we conduct a study in which programmers are presented with a regex and asked comprehension questions about its matching behavior.  By comparing accuracy between regexes that match the same language but are expressed differently (e.g., \verb!tri[a-f]3! and \verb!tri(a|b|c|d|e|f)3!), we can measure understandability and identify code smells. This analysis requires identification of equivalence classes for regexes. By inspecting  nearly 14,000 regexes extracted from Python projects in a publicly available dataset~\cite{chapman2016}, we formed an initial set of five equivalence classes to explore. \\
% as measured by identifying matching strings and by composing matching strings

\noindent {\textbf{RQ2:}} {\em Which regex representations have the strongest {community support} based on  frequency?} % each representation appears in regexes in open source Python projects?}
To answer RQ2, we explore the publicly available regex dataset~\cite{chapman2016} and use the presence and absence of language features as a proxy for community support, where more frequently-used features are assumed to be more understandable.\\

\noindent {\textbf{RQ3:}}  {\em Which regex representations are most desirable (i.e., least smelly) based on both community support and understandability?}
Based on RQ1 and RQ2, we identify smelly and non-smelly regex features  based on a combination of comprehension metrics and community support. \\

Next, we present the equivalence classes, analysis and results for each RQ, and a unified discussion.

\input{equivalenceClasses.tex}

%First we define a 'Functional Regex'(FR) as some regex that performs in a specific way.  For many FRs, there are several concrete ways to express a single FR.
%We define a concrete regex(CR) as a regex expressed with a particular pattern String.
%Here is one illustration of these definitions:
%
%\todoNow{create some examples for these terms}
%
%We identified 10 loose groups of FRs, described in this table:
%
%\todoNow{create a table explaining the 10 groups}
%
%For each of these groups we created either two concrete versions of three FRs or three concrete versions of two FRs.
%
%Each of the 10 categories had 6 concrete versions of some FR and so there are 60 CRs.  For each CR, we selected 5 \emph{example strings} designed to test the understanding of the CR.  The idea is that different CRs may have different levels of readability, even when they are representing the same FR.  We define readability as the ability to look at the CR and determine if an \emph{example string} can be matched by it or not.
%
%\todoNow{create some illustration of one matching subtask}
%



\input{rq2}
\input{rq1}
\input{rq3}
